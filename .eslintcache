[{"/Users/albert/Desktop/-/src/index.js":"1","/Users/albert/Desktop/-/src/App.js":"2","/Users/albert/Desktop/-/src/store/index.js":"3","/Users/albert/Desktop/-/src/store/GameState.js":"4","/Users/albert/Desktop/-/src/Components/ReadyGo.js":"5","/Users/albert/Desktop/-/src/Components/PieceQueue.js":"6","/Users/albert/Desktop/-/src/Components/Grid.js":"7","/Users/albert/Desktop/-/src/Components/HeldBlock.js":"8","/Users/albert/Desktop/-/src/Components/Tetrimino.js":"9","/Users/albert/Desktop/-/src/Components/PieceQueuePiece.js":"10","/Users/albert/Desktop/-/src/Components/Block.js":"11","/Users/albert/Desktop/-/src/modules/piece-queue.js":"12"},{"size":304,"mtime":1655620127636,"results":"13","hashOfConfig":"14"},{"size":4635,"mtime":1656366911617,"results":"15","hashOfConfig":"14"},{"size":195,"mtime":1655620503229,"results":"16","hashOfConfig":"14"},{"size":17956,"mtime":1656312580886,"results":"17","hashOfConfig":"14"},{"size":278,"mtime":1656364861842,"results":"18","hashOfConfig":"14"},{"size":537,"mtime":1656313639969,"results":"19","hashOfConfig":"14"},{"size":583,"mtime":1656366922023,"results":"20","hashOfConfig":"14"},{"size":1398,"mtime":1656220712156,"results":"21","hashOfConfig":"14"},{"size":2959,"mtime":1656189967628,"results":"22","hashOfConfig":"14"},{"size":627,"mtime":1656313127480,"results":"23","hashOfConfig":"14"},{"size":213,"mtime":1656052624461,"results":"24","hashOfConfig":"14"},{"size":623,"mtime":1656140900696,"results":"25","hashOfConfig":"14"},{"filePath":"26","messages":"27","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"1d6moc6",{"filePath":"28","messages":"29","errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"30"},{"filePath":"31","messages":"32","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"33","messages":"34","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"35"},{"filePath":"36","messages":"37","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"38","messages":"39","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"40","messages":"41","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"42"},{"filePath":"43","messages":"44","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"45","messages":"46","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"47"},{"filePath":"48","messages":"49","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"50","messages":"51","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"52","messages":"53","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"/Users/albert/Desktop/-/src/index.js",[],"/Users/albert/Desktop/-/src/App.js",["54","55"],"import { Fragment, useEffect } from \"react\";\nimport { useSelector, useDispatch } from \"react-redux\";\n\nimport styles from \"./gameUI.module.css\";\n\nimport { gameStateActions } from \"./store/GameState\";\nimport Grid from \"./Components/Grid\";\nimport PieceQueue from \"./Components/PieceQueue\";\nimport HeldBlock from \"./Components/HeldBlock\";\nimport ReadyGo from './Components/ReadyGo'\n\nfunction App() {\n  const dispatch = useDispatch();\n  const gameState = useSelector((state) => state.gameState);\n  const buttonClickHander = () => {\n    dispatch(gameStateActions.newGame());\n    dispatch(gameStateActions.getNewPiece());\n  };\n  const rotateButtonHandler = () => {\n    dispatch(gameStateActions.rotatePiece());\n  };\n  const dropPieceHandler = () => {\n    dispatch(gameStateActions.dropPiece());\n  };\n  const shiftLeftHandler = () => {\n    dispatch(gameStateActions.shiftLeft());\n  };\n  const shiftRightHandler = () => {\n    dispatch(gameStateActions.shiftRight());\n  };\n\n  let keyState = {};\n\n  window.addEventListener(\"keydown\", (event) => {\n    if (event.key === \"Tab\") {\n      event.preventDefault();\n      event.stopPropagation();\n    }\n    if (event.key === \" \") {\n      event.preventDefault();\n      event.stopPropagation();\n    }\n    keyState[event.key] = true;\n  });\n  window.addEventListener(\"keyup\", (event) => {\n    keyState[event.key] = false;\n  });\n\n  const gameLoop = () => {\n    if (gameState.gameRunning) {\n      if (gameState.currentPieceState === \"FROZEN\") {\n        dispatch(gameStateActions.clearLines());\n        dispatch(gameStateActions.checkIfGameWon());\n        dispatch(gameStateActions.getNewPiece());\n        dispatch(gameStateActions.getGhostCoords());\n        dispatch(gameStateActions.showGhostPiece());\n      } else {\n        dispatch(gameStateActions.dropPiece());\n        dispatch(gameStateActions.getGhostCoords());\n        dispatch(gameStateActions.showGhostPiece());\n      }\n    }\n  };\n\n  useEffect(() => {\n    const dropPieceInterval = window.setInterval(() => {\n      gameLoop();\n    }, 300);\n    const handleInputInterval = window.setInterval(() => {\n      keyHandler();\n    }, 10);\n    return () => {\n      window.clearInterval(dropPieceInterval);\n      window.clearInterval(handleInputInterval);\n    };\n  }, [gameState, gameLoop, keyState]);\n\n  useEffect(() => {\n    const interval = window.setInterval(() => {\n      dispatch(gameStateActions.gettingReady());\n    }, 500);\n    return () => {\n      window.clearInterval(interval);\n    };\n  }, [gameState.displayMessage, dispatch]);\n\n  const keyHandler = () => {\n    if (!gameState.gameRunning) {\n      return;\n    }\n    if (keyState[\"q\"]) {\n      dispatch(gameStateActions.rotatePiece(true));\n      dispatch(gameStateActions.getGhostCoords());\n      dispatch(gameStateActions.showGhostPiece());\n    }\n    if (keyState[\"w\"]) {\n      dispatch(gameStateActions.rotatePiece(false));\n      dispatch(gameStateActions.getGhostCoords());\n      dispatch(gameStateActions.showGhostPiece());\n    }\n    if (keyState[\"ArrowDown\"]) {\n      dispatch(gameStateActions.dropPiece());\n    }\n    if (keyState[\"ArrowRight\"]) {\n      dispatch(gameStateActions.shiftRight());\n      dispatch(gameStateActions.getGhostCoords());\n      dispatch(gameStateActions.showGhostPiece());\n    }\n    if (keyState[\"ArrowLeft\"]) {\n      dispatch(gameStateActions.shiftLeft());\n      dispatch(gameStateActions.getGhostCoords());\n      dispatch(gameStateActions.showGhostPiece());\n    }\n    if (keyState[\" \"]) {\n      dispatch(gameStateActions.hardDrop());\n    }\n    if (keyState[\"Tab\"]) {\n      dispatch(gameStateActions.holdPiece());\n      dispatch(gameStateActions.getGhostCoords());\n      dispatch(gameStateActions.showGhostPiece());\n    }\n  };\n  document.onkeydown = (keycode) => {\n    if (keycode.key === \"Escape\") {\n      dispatch(gameStateActions.newGame());\n      dispatch(gameStateActions.getNewPiece());\n      dispatch(gameStateActions.getGhostCoords());\n      dispatch(gameStateActions.showGhostPiece());\n    }\n  };\n  return (\n    <Fragment>\n      <h1>Ditris</h1>\n      <button onClick={buttonClickHander}>Start/Pause</button>\n      <button onClick={rotateButtonHandler}>Rotate</button>\n      <button onClick={dropPieceHandler}>Drop</button>\n      <button onClick={shiftLeftHandler}>Left</button>\n      <button onClick={shiftRightHandler}>Right</button>\n      <div className={styles.gameUI}>\n        <HeldBlock />\n        <Grid>\n          <div  style={{ \"align-items\":\"center\",position: \"absolute\", top: 300,color:\"yellow\"}}>\n            {gameState.displayMessage}\n          </div>\n        </Grid>\n        <PieceQueue />\n      </div>\n    </Fragment>\n  );\n}\n\nexport default App;\n","/Users/albert/Desktop/-/src/store/index.js",[],"/Users/albert/Desktop/-/src/store/GameState.js",["56"],"import { createSlice } from \"@reduxjs/toolkit\";\n\nimport { TETRIMINOS } from \"../Components/Tetrimino\";\n\nimport Queue from '../modules/piece-queue'\n\nlet pieceArray = [\n  \"I\",\n  \"I\",\n  \"T\",\n  \"T\",\n  \"L\",\n  \"L\",\n  \"J\",\n  \"J\",\n  \"Z\",\n  \"Z\",\n  \"S\",\n  \"S\",\n  \"O\",\n  \"O\",\n];\nconst getRandomPiece = () => {\n  if(pieceArray.length===0){\n    pieceArray = [\n      \"I\",\n      \"I\",\n      \"T\",\n      \"T\",\n      \"L\",\n      \"L\",\n      \"J\",\n      \"J\",\n      \"Z\",\n      \"Z\",\n      \"S\",\n      \"S\",\n      \"O\",\n      \"O\",\n    ];\n  }\n  const value = Math.floor(pieceArray.length * Math.random());\n  return pieceArray.splice(value,1)\n};\n\nconst getCoords = (type, rotatePos, xPos, yPos) =>\n  TETRIMINOS[type][rotatePos].map((row, rowPos) =>\n    row.map((col, colPos) => {\n      if (col) {\n        return { x: xPos + colPos, y: yPos + rowPos };\n      }\n      return null;\n    })\n  );\n\nconst rotatePiece = (isCounterClockwise, state) => {\n  let { rotatePos } = state;\n  if (isCounterClockwise) {\n    if (rotatePos === 0) {\n      return 3;\n    } else {\n      return rotatePos - 1;\n    }\n  } else {\n    if (rotatePos === 3) {\n      return 0;\n    } else {\n      return rotatePos + 1;\n    }\n  }\n};\n\nconst convertMappingToCoords = (state, mapping, forGhost = false) => {\n  let coordArray = [];\n  for (const array of mapping) {\n    for (const coord of array) {\n      if (coord) {\n        if (coordIsValid(state, coord, forGhost)) {\n          coordArray.push(coord);\n        }\n      }\n    }\n  }\n  return coordArray;\n};\n\nconst gameStateInitialState = {\n  gameRunning: false,\n  currentShape: null,\n  currentCoords: [],\n  ghostCoords: [],\n  currentPieceState: \"NONE\",\n  rotatePos: 0,\n  xPos: 3,\n  yPos: 0,\n  totalLinesCleared: 0,\n  grid: [\n    [\n      \"None\",\n      \"None\",\n      \"None\",\n      \"None\",\n      \"None\",\n      \"None\",\n      \"None\",\n      \"None\",\n      \"None\",\n      \"None\",\n    ],\n    [\n      \"None\",\n      \"None\",\n      \"None\",\n      \"None\",\n      \"None\",\n      \"None\",\n      \"None\",\n      \"None\",\n      \"None\",\n      \"None\",\n    ],\n    [\n      \"None\",\n      \"None\",\n      \"None\",\n      \"None\",\n      \"None\",\n      \"None\",\n      \"None\",\n      \"None\",\n      \"None\",\n      \"None\",\n    ],\n    [\n      \"None\",\n      \"None\",\n      \"None\",\n      \"None\",\n      \"None\",\n      \"None\",\n      \"None\",\n      \"None\",\n      \"None\",\n      \"None\",\n    ],\n    [\n      \"None\",\n      \"None\",\n      \"None\",\n      \"None\",\n      \"None\",\n      \"None\",\n      \"None\",\n      \"None\",\n      \"None\",\n      \"None\",\n    ],\n    [\n      \"None\",\n      \"None\",\n      \"None\",\n      \"None\",\n      \"None\",\n      \"None\",\n      \"None\",\n      \"None\",\n      \"None\",\n      \"None\",\n    ],\n    [\n      \"None\",\n      \"None\",\n      \"None\",\n      \"None\",\n      \"None\",\n      \"None\",\n      \"None\",\n      \"None\",\n      \"None\",\n      \"None\",\n    ],\n    [\n      \"None\",\n      \"None\",\n      \"None\",\n      \"None\",\n      \"None\",\n      \"None\",\n      \"None\",\n      \"None\",\n      \"None\",\n      \"None\",\n    ],\n    [\n      \"None\",\n      \"None\",\n      \"None\",\n      \"None\",\n      \"None\",\n      \"None\",\n      \"None\",\n      \"None\",\n      \"None\",\n      \"None\",\n    ],\n    [\n      \"None\",\n      \"None\",\n      \"None\",\n      \"None\",\n      \"None\",\n      \"None\",\n      \"None\",\n      \"None\",\n      \"None\",\n      \"None\",\n    ],\n    [\n      \"None\",\n      \"None\",\n      \"None\",\n      \"None\",\n      \"None\",\n      \"None\",\n      \"None\",\n      \"None\",\n      \"None\",\n      \"None\",\n    ],\n    [\n      \"None\",\n      \"None\",\n      \"None\",\n      \"None\",\n      \"None\",\n      \"None\",\n      \"None\",\n      \"None\",\n      \"None\",\n      \"None\",\n    ],\n    [\n      \"None\",\n      \"None\",\n      \"None\",\n      \"None\",\n      \"None\",\n      \"None\",\n      \"None\",\n      \"None\",\n      \"None\",\n      \"None\",\n    ],\n    [\n      \"None\",\n      \"None\",\n      \"None\",\n      \"None\",\n      \"None\",\n      \"None\",\n      \"None\",\n      \"None\",\n      \"None\",\n      \"None\",\n    ],\n    [\n      \"None\",\n      \"None\",\n      \"None\",\n      \"None\",\n      \"None\",\n      \"None\",\n      \"None\",\n      \"None\",\n      \"None\",\n      \"None\",\n    ],\n    [\n      \"None\",\n      \"None\",\n      \"None\",\n      \"None\",\n      \"None\",\n      \"None\",\n      \"None\",\n      \"None\",\n      \"None\",\n      \"None\",\n    ],\n    [\n      \"None\",\n      \"None\",\n      \"None\",\n      \"None\",\n      \"None\",\n      \"None\",\n      \"None\",\n      \"None\",\n      \"None\",\n      \"None\",\n    ],\n    [\n      \"None\",\n      \"None\",\n      \"None\",\n      \"None\",\n      \"None\",\n      \"None\",\n      \"None\",\n      \"None\",\n      \"None\",\n      \"None\",\n    ],\n    [\n      \"None\",\n      \"None\",\n      \"None\",\n      \"None\",\n      \"None\",\n      \"None\",\n      \"None\",\n      \"None\",\n      \"None\",\n      \"None\",\n    ],\n    [\n      \"None\",\n      \"None\",\n      \"None\",\n      \"None\",\n      \"None\",\n      \"None\",\n      \"None\",\n      \"None\",\n      \"None\",\n      \"None\",\n    ],\n    [\n      \"None\",\n      \"None\",\n      \"None\",\n      \"None\",\n      \"None\",\n      \"None\",\n      \"None\",\n      \"None\",\n      \"None\",\n      \"None\",\n    ],\n  ],\n  // winCondition:(state) =>{return state.totalLinesCleared >= 5},\n  pieceQueue: null,\n  isGameWon: false,\n  heldPiece: null,\n  rotated: false,\n\n};\n\nconst removeLastState = (state) => {\n  for (const coord of state.currentCoords) {\n    state.grid[coord.y][coord.x] = \"None\";\n  }\n};\n\nconst removeLastGhostPiece = (state) => {\n  for (const coord of state.ghostCoords) {\n    state.grid[coord.y][coord.x] = \"None\";\n  }\n};\n\nconst placeBlocks = (state, forGhost = false) => {\n  if (forGhost) {\n    const colorName = state.currentShape + \"ghost\";\n    for (const coord of state.ghostCoords) {\n      state.grid[coord.y][coord.x] = colorName;\n      for (const currentCoord of state.currentCoords) {\n        if (currentCoord.y === coord.y && currentCoord.x === coord.x) {\n          state.grid[coord.y][coord.x] = state.currentShape;\n        }\n      }\n    }\n  } else {\n    for (const coord of state.currentCoords) {\n      state.grid[coord.y][coord.x] = state.currentShape;\n    }\n  }\n};\n\nconst coordIsValid = (state, coord, forGhost = false) => {\n  if (coord) {\n    if (coord.y <= 20 && coord.x >= 0 && coord.x <= 9) {\n      for (let currentCoord of state.currentCoords) {\n        if (forGhost) {\n          if (currentCoord.y === coord.y && currentCoord.x === coord.x) {\n            return true;\n          }\n        }\n      }\n      if (state.grid[coord.y][coord.x].length > 1) {\n        return true;\n      }\n    }\n  }\n  return false;\n};\n\nconst winCondition = (state) => state.totalLinesCleared > 4;\n\nexport let pieceQueue = new Queue()\n\nconst gameStateSlice = createSlice({\n  name: \"gameState\",\n  initialState: gameStateInitialState,\n  reducers: {\n    newGame(state) {\n      pieceArray = [\n        \"I\",\n        \"I\",\n        \"T\",\n        \"T\",\n        \"L\",\n        \"L\",\n        \"J\",\n        \"J\",\n        \"Z\",\n        \"Z\",\n        \"S\",\n        \"S\",\n        \"O\",\n        \"O\",\n      ];\n      state.grid = [\n        [\n          \"None\",\n          \"None\",\n          \"None\",\n          \"None\",\n          \"None\",\n          \"None\",\n          \"None\",\n          \"None\",\n          \"None\",\n          \"None\",\n        ],\n        [\n          \"None\",\n          \"None\",\n          \"None\",\n          \"None\",\n          \"None\",\n          \"None\",\n          \"None\",\n          \"None\",\n          \"None\",\n          \"None\",\n        ],\n        [\n          \"None\",\n          \"None\",\n          \"None\",\n          \"None\",\n          \"None\",\n          \"None\",\n          \"None\",\n          \"None\",\n          \"None\",\n          \"None\",\n        ],\n        [\n          \"None\",\n          \"None\",\n          \"None\",\n          \"None\",\n          \"None\",\n          \"None\",\n          \"None\",\n          \"None\",\n          \"None\",\n          \"None\",\n        ],\n        [\n          \"None\",\n          \"None\",\n          \"None\",\n          \"None\",\n          \"None\",\n          \"None\",\n          \"None\",\n          \"None\",\n          \"None\",\n          \"None\",\n        ],\n        [\n          \"None\",\n          \"None\",\n          \"None\",\n          \"None\",\n          \"None\",\n          \"None\",\n          \"None\",\n          \"None\",\n          \"None\",\n          \"None\",\n        ],\n        [\n          \"None\",\n          \"None\",\n          \"None\",\n          \"None\",\n          \"None\",\n          \"None\",\n          \"None\",\n          \"None\",\n          \"None\",\n          \"None\",\n        ],\n        [\n          \"None\",\n          \"None\",\n          \"None\",\n          \"None\",\n          \"None\",\n          \"None\",\n          \"None\",\n          \"None\",\n          \"None\",\n          \"None\",\n        ],\n        [\n          \"None\",\n          \"None\",\n          \"None\",\n          \"None\",\n          \"None\",\n          \"None\",\n          \"None\",\n          \"None\",\n          \"None\",\n          \"None\",\n        ],\n        [\n          \"None\",\n          \"None\",\n          \"None\",\n          \"None\",\n          \"None\",\n          \"None\",\n          \"None\",\n          \"None\",\n          \"None\",\n          \"None\",\n        ],\n        [\n          \"None\",\n          \"None\",\n          \"None\",\n          \"None\",\n          \"None\",\n          \"None\",\n          \"None\",\n          \"None\",\n          \"None\",\n          \"None\",\n        ],\n        [\n          \"None\",\n          \"None\",\n          \"None\",\n          \"None\",\n          \"None\",\n          \"None\",\n          \"None\",\n          \"None\",\n          \"None\",\n          \"None\",\n        ],\n        [\n          \"None\",\n          \"None\",\n          \"None\",\n          \"None\",\n          \"None\",\n          \"None\",\n          \"None\",\n          \"None\",\n          \"None\",\n          \"None\",\n        ],\n        [\n          \"None\",\n          \"None\",\n          \"None\",\n          \"None\",\n          \"None\",\n          \"None\",\n          \"None\",\n          \"None\",\n          \"None\",\n          \"None\",\n        ],\n        [\n          \"None\",\n          \"None\",\n          \"None\",\n          \"None\",\n          \"None\",\n          \"None\",\n          \"None\",\n          \"None\",\n          \"None\",\n          \"None\",\n        ],\n        [\n          \"None\",\n          \"None\",\n          \"None\",\n          \"None\",\n          \"None\",\n          \"None\",\n          \"None\",\n          \"None\",\n          \"None\",\n          \"None\",\n        ],\n        [\n          \"None\",\n          \"None\",\n          \"None\",\n          \"None\",\n          \"None\",\n          \"None\",\n          \"None\",\n          \"None\",\n          \"None\",\n          \"None\",\n        ],\n        [\n          \"None\",\n          \"None\",\n          \"None\",\n          \"None\",\n          \"None\",\n          \"None\",\n          \"None\",\n          \"None\",\n          \"None\",\n          \"None\",\n        ],\n        [\n          \"None\",\n          \"None\",\n          \"None\",\n          \"None\",\n          \"None\",\n          \"None\",\n          \"None\",\n          \"None\",\n          \"None\",\n          \"None\",\n        ],\n        [\n          \"None\",\n          \"None\",\n          \"None\",\n          \"None\",\n          \"None\",\n          \"None\",\n          \"None\",\n          \"None\",\n          \"None\",\n          \"None\",\n        ],\n        [\n          \"None\",\n          \"None\",\n          \"None\",\n          \"None\",\n          \"None\",\n          \"None\",\n          \"None\",\n          \"None\",\n          \"None\",\n          \"None\",\n        ],\n      ];\n      state.xPos = 3;\n      state.yPos = 0;\n      state.rotatePos = 0;\n      state.displayMessage = \"READY\"\n      state.currentPieceState = \"GETTING READY\"\n      pieceQueue.empty()\n      state.gameRunning = false;\n    },\n    gettingReady(state){\n      if (state.currentPieceState === \"GETTING READY\"){\n        state.currentPieceState = \"BEFORE START\"\n        state.displayMessage = \"GO!\"\n      }\n      else if (state.currentPieceState === \"BEFORE START\"){\n        state.displayMessage = null;\n        state.gameRunning = true;\n        state.currentShape = getRandomPiece();\n        for(let i = 0;i<5;i++){\n          pieceQueue.enqueue(...getRandomPiece())\n        }\n      }\n    },\n    clearLines(state) {\n      let newGrid = [];\n      let linesCleared = 0;\n      for (const row of state.grid) {\n        if (row.every((blockType) => blockType !== \"None\")) {\n          state.totalLinesCleared += 1;\n          linesCleared += 1;\n        } else {\n          newGrid.push(row);\n        }\n      }\n      for (let i = 0; i < linesCleared; i++) {\n        newGrid.unshift([\n          \"None\",\n          \"None\",\n          \"None\",\n          \"None\",\n          \"None\",\n          \"None\",\n          \"None\",\n          \"None\",\n          \"None\",\n          \"None\",\n        ]);\n      }\n      state.grid = newGrid;\n    },\n    getNewPiece(state) {\n      if (!state.gameRunning) {\n        return;\n      }\n      state.ghostCoords = [];\n      state.rotated = false\n      state.currentShape = pieceQueue.dequeue();\n      pieceQueue.enqueue(...getRandomPiece())\n      state.xPos = 3;\n      state.yPos = 0;\n      state.rotatePos = 0;\n      state.currentCoords = convertMappingToCoords(\n        state,\n        getCoords(state.currentShape, state.rotatePos, state.xPos, state.yPos)\n      );\n      if (state.currentCoords.length < 4) {\n        state.gameRunning = false;\n        console.log(\"lost\");\n        return;\n      }\n      placeBlocks(state);\n      state.currentPieceState = \"FALLING\";\n    },\n    rotatePiece(state, action) {\n      const originalRotatePos = state.rotatePos;\n      state.rotatePos = rotatePiece(action.payload, {\n        rotatePos: state.rotatePos,\n      });\n      removeLastState(state);\n      state.currentCoords = convertMappingToCoords(\n        state,\n        getCoords(state.currentShape, state.rotatePos, state.xPos, state.yPos)\n      );\n      if (state.currentCoords.length < 4) {\n        state.rotatePos = originalRotatePos;\n        state.currentCoords = convertMappingToCoords(\n          state,\n          getCoords(state.currentShape, state.rotatePos, state.xPos, state.yPos)\n        );\n      } else {\n        state.currentPieceState = \"FALLING\";\n      }\n      placeBlocks(state);\n    },\n    dropPiece(state) {\n      if (state.gameRunning) {\n        if (state.currentPieceState === \"LANDING\") {\n          state.currentPieceState = \"FROZEN\";\n          return;\n        }\n        removeLastState(state);\n        state.yPos += 1;\n        state.currentCoords = convertMappingToCoords(\n          state,\n          getCoords(state.currentShape, state.rotatePos, state.xPos, state.yPos)\n        );\n        if (state.currentCoords.length < 4) {\n          state.yPos -= 1;\n          state.currentCoords = convertMappingToCoords(\n            state,\n            getCoords(\n              state.currentShape,\n              state.rotatePos,\n              state.xPos,\n              state.yPos\n            )\n          );\n          state.currentPieceState = \"LANDING\";\n        } else {\n          state.currentPieceState = \"FALLING\";\n        }\n        placeBlocks(state);\n      } else {\n      }\n    },\n    getGhostCoords(state) {\n      if (!state.gameRunning) {\n        return;\n      }\n      removeLastGhostPiece(state);\n      state.ghostCoords = [];\n      for (let coord of state.currentCoords) {\n        state.ghostCoords.push({ x: coord.x, y: coord.y });\n      }\n      let ghostYPos = state.yPos;\n      while (state.ghostCoords.length === 4) {\n        ghostYPos += 1;\n        state.ghostCoords = convertMappingToCoords(\n          state,\n          getCoords(state.currentShape, state.rotatePos, state.xPos, ghostYPos),\n          true\n        );\n      }\n      ghostYPos -= 1;\n      state.ghostCoords = convertMappingToCoords(\n        state,\n        getCoords(state.currentShape, state.rotatePos, state.xPos, ghostYPos),\n        true\n      );\n    },\n    hardDrop(state) {\n      removeLastState(state);\n      state.currentCoords = state.ghostCoords;\n      placeBlocks(state);\n      state.currentPieceState = \"FROZEN\";\n    },\n    showGhostPiece(state) {\n      if (!state.gameRunning) {\n        return;\n      }\n      placeBlocks(state, true);\n    },\n    shiftLeft(state) {\n      removeLastState(state);\n      state.xPos -= 1;\n      state.currentCoords = convertMappingToCoords(\n        state,\n        getCoords(state.currentShape, state.rotatePos, state.xPos, state.yPos)\n      );\n      if (state.currentCoords.length < 4) {\n        state.xPos += 1;\n        state.currentCoords = convertMappingToCoords(\n          state,\n          getCoords(state.currentShape, state.rotatePos, state.xPos, state.yPos)\n        );\n      } else {\n        state.currentPieceState = \"FALLING\";\n      }\n      placeBlocks(state);\n    },\n    shiftRight(state) {\n      removeLastState(state);\n      state.xPos += 1;\n      state.currentCoords = convertMappingToCoords(\n        state,\n        getCoords(state.currentShape, state.rotatePos, state.xPos, state.yPos)\n      );\n      if (state.currentCoords.length < 4) {\n        state.xPos -= 1;\n        state.currentCoords = convertMappingToCoords(\n          state,\n          getCoords(state.currentShape, state.rotatePos, state.xPos, state.yPos)\n        );\n      } else {\n        state.currentPieceState = \"FALLING\";\n      }\n      placeBlocks(state);\n    },\n    checkIfGameWon(state) {\n      if (state.totalLinesCleared >= 4) {\n        console.log(\"won\");\n        state.isGameWon = true;\n        state.gameRunning = false;\n      }\n    },\n    holdPiece(state){\n      if(state.rotated === true){\n        return\n      }\n      state.rotated = true;\n\n      \n      removeLastState(state);\n      if(state.heldPiece===null){\n        state.heldPiece = state.currentShape\n        state.currentShape = pieceQueue.dequeue();\n        pieceQueue.enqueue(...getRandomPiece())\n      }\n      else{\n        const placeHolder = state.currentShape\n        state.currentShape = state.heldPiece\n        state.heldPiece = placeHolder;\n      }\n      state.xPos = 3;\n      state.yPos = 0;\n      state.rotatePos = 0;\n      state.currentCoords = convertMappingToCoords(\n        state,\n        getCoords(state.currentShape, state.rotatePos, state.xPos, state.yPos)\n      );\n      placeBlocks(state);\n      state.currentPieceState = \"FALLING\";\n\n    }\n\n    // setWinCondition(state,condition){\n    //   state.winCondition = condition;\n    // }\n  },\n});\n\nexport const gameStateActions = gameStateSlice.actions;\n\nexport default gameStateSlice.reducer;\n","/Users/albert/Desktop/-/src/Components/ReadyGo.js",[],"/Users/albert/Desktop/-/src/Components/PieceQueue.js",[],"/Users/albert/Desktop/-/src/Components/Grid.js",["57"],"import { useSelector, useDispatch } from \"react-redux\";\n\nimport styles from \"./Grid.module.css\";\nimport Block from \"./Block\";\n\nconst Grid = (props) => {\n\n  const gameState = useSelector((state) => state.gameState);\n\n  const grid = gameState.grid.slice(1).map((row, y_pos) => {\n    return (\n      <tr key={y_pos}>\n        {row.map((color, x_pos) => {\n          return <Block color={color} key={x_pos} />;\n        })}\n      </tr>\n    );\n  });\n\n  return (\n    <table className={styles.grid}>\n      <tbody>{grid}</tbody>\n      {props.children}\n    </table>\n  );\n};\n\nexport default Grid;\n","/Users/albert/Desktop/-/src/Components/HeldBlock.js",[],"/Users/albert/Desktop/-/src/Components/Tetrimino.js",["58"],"export const TETRIMINOS = {\n  I: [\n    //I\n    [\n      [1, 1, 1, 1],\n      [0, 0, 0, 0],\n    ],\n    [\n      [0, 0, 1, 0],\n      [0, 0, 1, 0],\n      [0, 0, 1, 0],\n      [0, 0, 1, 0],\n    ],\n    [\n      [0, 0, 0, 0],\n      [0, 0, 0, 0],\n      [1, 1, 1, 1],\n      [0, 0, 0, 0],\n    ],\n    [\n      [0, 1, 0, 0],\n      [0, 1, 0, 0],\n      [0, 1, 0, 0],\n      [0, 1, 0, 0],\n    ],\n  ],\n\n  T: [\n    //T\n    [\n      [0, 1, 0],\n      [1, 1, 1],\n    ],\n    [\n      [0, 1, 0],\n      [0, 1, 1],\n      [0, 1, 0],\n    ],\n    [\n      [0, 0, 0],\n      [1, 1, 1],\n      [0, 1, 0],\n    ],\n    [\n      [0, 1, 0],\n      [1, 1, 0],\n      [0, 1, 0],\n    ],\n  ],\n  L: [\n    //L\n    [\n      [0, 0, 1],\n      [1, 1, 1],\n    ],\n    [\n      [0, 1, 0],\n      [0, 1, 0],\n      [0, 1, 1],\n    ],\n    [\n      [0, 0, 0],\n      [1, 1, 1],\n      [1, 0, 0],\n    ],\n    [\n      [1, 1, 0],\n      [0, 1, 0],\n      [0, 1, 0],\n    ],\n  ],\n  J: [\n    //J\n    [\n      [1, 0, 0],\n      [1, 1, 1],\n    ],\n    [\n      [0, 1, 1],\n      [0, 1, 0],\n      [0, 1, 0],\n    ],\n    [\n      [0, 0, 0],\n      [1, 1, 1],\n      [0, 0, 1],\n    ],\n    [\n      [0, 1, 0],\n      [0, 1, 0],\n      [1, 1, 0],\n    ],\n  ],\n  Z: [\n    //Z\n    [\n      [1, 1, 0],\n      [0, 1, 1],\n    ],\n    [\n      [0, 0, 1],\n      [0, 1, 1],\n      [0, 1, 0],\n    ],\n    [\n      [0, 0, 0],\n      [1, 1, 0],\n      [0, 1, 1],\n    ],\n    [\n      [0, 1, 0],\n      [1, 1, 0],\n      [1, 0, 0],\n    ],\n  ],\n  S: [\n    //S\n    [\n      [0, 1, 1],\n      [1, 1, 0],\n    ],\n    [\n      [0, 1, 0],\n      [0, 1, 1],\n      [0, 0, 1],\n    ],\n    [\n      [0, 0, 0],\n      [0, 1, 1],\n      [1, 1, 0],\n    ],\n    [\n      [1, 0, 0],\n      [1, 1, 0],\n      [0, 1, 0],\n    ],\n  ],\n  O: [\n    //O\n    [\n      [0, 1, 1],\n      [0, 1, 1],\n    ],\n    [\n      [0, 1, 1],\n      [0, 1, 1],\n    ],\n    [\n      [0, 1, 1],\n      [0, 1, 1],\n    ],\n    [\n      [0, 1, 1],\n      [0, 1, 1],\n    ],\n  ],\n};\n\nexport const getRandomPiece = () => {\n  const value = Math.round(6 * Math.random());\n  switch (value) {\n    case 0:\n      return \"I\";\n    case 1:\n      return \"T\";\n    case 2:\n      return \"L\";\n    case 3:\n      return \"J\";\n    case 4:\n      return \"Z\";\n    case 5:\n      return \"S\";\n    case 6:\n      return \"O\";\n  }\n};\n\nexport const getPiece = (type, rotatePos, xPos, yPos) =>\n  TETRIMINOS[type][rotatePos].map((row, rowPos) =>\n    row.map((col, colPos) => {\n      if (col) {\n        return { x: xPos + colPos, y: yPos + rowPos };\n      }\n      return null;\n    })\n  );\n\nexport const rotatePiece = (isCounterClockwise, { type, rotatePos }) => {\n  return isCounterClockwise\n    ? rotatePos === 0\n      ? TETRIMINOS[type].length - 1\n      : rotatePos - 1\n    : rotatePos === TETRIMINOS[type].length - 1\n    ? 0\n    : rotatePos + 1;\n};\n\nexport const convertMappingToCoords = (mapping) => {\n  let coordArray = [];\n  for (const array of mapping) {\n    for (const coord of array) {\n      if (coord) {\n        coordArray.push(coord);\n      }\n    }\n  }\n  return coordArray;\n};\n","/Users/albert/Desktop/-/src/Components/PieceQueuePiece.js",[],"/Users/albert/Desktop/-/src/Components/Block.js",[],"/Users/albert/Desktop/-/src/modules/piece-queue.js",[],{"ruleId":"59","severity":1,"message":"60","line":10,"column":8,"nodeType":"61","messageId":"62","endLine":10,"endColumn":15},{"ruleId":"63","severity":1,"message":"64","line":76,"column":6,"nodeType":"65","endLine":76,"endColumn":37,"suggestions":"66"},{"ruleId":"59","severity":1,"message":"67","line":407,"column":7,"nodeType":"61","messageId":"62","endLine":407,"endColumn":19},{"ruleId":"59","severity":1,"message":"68","line":1,"column":23,"nodeType":"61","messageId":"62","endLine":1,"endColumn":34},{"ruleId":"69","severity":1,"message":"70","line":161,"column":3,"nodeType":"71","messageId":"72","endLine":176,"endColumn":4},"no-unused-vars","'ReadyGo' is defined but never used.","Identifier","unusedVar","react-hooks/exhaustive-deps","React Hook useEffect has a missing dependency: 'keyHandler'. Either include it or remove the dependency array.","ArrayExpression",["73"],"'winCondition' is assigned a value but never used.","'useDispatch' is defined but never used.","default-case","Expected a default case.","SwitchStatement","missingDefaultCase",{"desc":"74","fix":"75"},"Update the dependencies array to be: [gameState, gameLoop, keyState, keyHandler]",{"range":"76","text":"77"},[2243,2274],"[gameState, gameLoop, keyState, keyHandler]"]